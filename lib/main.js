// Generated by CoffeeScript 1.10.0
(function() {
  var CND, LTSORT, NCR, alert, badge, debug, echo, help, info, log, rpr, urge, warn, whisper;

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'SHUNTING-YARD';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  warn = CND.get_logger('warn', badge);

  alert = CND.get_logger('alert', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  NCR = require('ncr');

  LTSORT = require('ltsort');

  this.new_grammar = function() {
    var R;
    R = {};
    R._operator_topograph = LTSORT.new_graph({
      loners: false
    });
    R.operators = {};
    R.lbrackets = {};
    R.rbrackets = {};
    return R;
  };

  this.new_token = function(me, symbol, cu_idx) {
    var R, operator, type;
    type = this._type_of_symbol(me, symbol);

    /* `t` for 'type' */
    R = {
      s: symbol,
      idx: cu_idx,
      t: type
    };
    switch (type) {
      case 'operator':
        operator = this._operator_from_symbol(me, symbol);
        R.a = operator.a;
        R.p = operator.p;
    }
    return R;
  };

  this._symbol_is_whitespace = function(me, symbol) {
    return /^\s*$/.test(symbol);
  };

  this._symbol_is_number = function(me, symbol) {
    return /^[0-9]+$/.test(symbol);
  };

  this._symbol_is_operator = function(me, symbol) {
    return symbol in me.operators;
  };

  this._symbol_is_lbracket = function(me, symbol) {
    return symbol in me.lbrackets;
  };

  this._symbol_is_rbracket = function(me, symbol) {
    return symbol in me.rbrackets;
  };

  this._type_of_symbol = function(me, symbol) {
    if (this._symbol_is_whitespace(me, symbol)) {
      return 'whitespace';
    }
    if (this._symbol_is_number(me, symbol)) {
      return 'number';
    }
    if (this._symbol_is_operator(me, symbol)) {
      return 'operator';
    }
    if (this._symbol_is_lbracket(me, symbol)) {
      return 'lbracket';
    }
    if (this._symbol_is_rbracket(me, symbol)) {
      return 'rbracket';
    }
    return 'name';
  };

  this.tokenize = function(me, source) {
    var R, chrs, cu_idx, i, len, symbol;
    R = [];
    chrs = NCR.chrs_from_text(source);
    cu_idx = 1;
    for (i = 0, len = chrs.length; i < len; i++) {
      symbol = chrs[i];
      R.push(this.new_token(me, symbol, cu_idx));

      /* we're counting JS code units here */
      cu_idx += symbol.length;
    }
    return R;
  };

  this.add_brackets = function(me, left_symbol, right_symbol) {
    if (me.lbrackets[left_symbol] != null) {
      throw new Error("### MEH ###");
    }
    if (me.lbrackets[right_symbol] != null) {
      throw new Error("### MEH ###");
    }
    if (me.rbrackets[left_symbol] != null) {
      throw new Error("### MEH ###");
    }
    if (me.rbrackets[right_symbol] != null) {
      throw new Error("### MEH ###");
    }
    me.lbrackets[left_symbol] = right_symbol;
    me.rbrackets[right_symbol] = left_symbol;
    return null;
  };

  this._lbracket_from_rbracket = function(me, rbracket) {
    var R, key;
    key = CND.isa_text(rbracket) ? rbracket : rbracket.s;
    if ((R = me.rbrackets[key]) == null) {
      throw new Error("not a right bracket: " + (rpr(rbracket)));
    }
    return R;
  };

  this.new_operator = function(me, symbol, associativity) {
    var R;
    if (me.operators[symbol] != null) {
      throw new Error("### MEH ###");
    }
    if (associativity == null) {
      associativity = 'left';
    }

    /* NOTE 'associativity' also called 'fixity' (see https://en.wikipedia.org/wiki/Operator_associativity) */

    /* `s` for 'symbol', `a` for 'associativity', `p` for 'precedence' */
    R = {
      s: symbol,
      a: associativity,
      p: null
    };
    me.operators[symbol] = R;
    return R;
  };

  this.set_operator_precedence = function(me, hi_symbols, lo_symbols) {
    var hi_symbol, i, j, len, len1, lo_symbol;
    if (!CND.isa_list(hi_symbols)) {
      hi_symbols = [hi_symbols];
    }
    if (!CND.isa_list(lo_symbols)) {
      lo_symbols = [lo_symbols];
    }
    for (i = 0, len = hi_symbols.length; i < len; i++) {
      hi_symbol = hi_symbols[i];
      for (j = 0, len1 = lo_symbols.length; j < len1; j++) {
        lo_symbol = lo_symbols[j];
        if (!CND.isa_text(hi_symbol)) {
          hi_symbol = hi_symbol.s;
        }
        if (!CND.isa_text(lo_symbol)) {
          lo_symbol = lo_symbol.s;
        }
        LTSORT.add(me._operator_topograph, hi_symbol, lo_symbol);
      }
    }
    return null;
  };

  this._operator_from_symbol = function(me, symbol) {
    var R;
    if ((R = me.operators[symbol]) == null) {
      throw new Error("symbol not known to be an operator: " + (rpr(symbol)));
    }
    return R;
  };

  this.compile_operators = function(me) {
    var group, group_idx, groups, i, j, len, len1, operator, symbol;
    LTSORT.linearize(me._operator_topograph);
    groups = LTSORT.group(me._operator_topograph);
    for (group_idx = i = 0, len = groups.length; i < len; group_idx = ++i) {
      group = groups[group_idx];
      for (j = 0, len1 = group.length; j < len1; j++) {
        symbol = group[j];
        operator = me.operators[symbol];
        if (operator == null) {
          operator = this.new_operator(me, symbol);
        }
        operator.p = groups.length - group_idx - 1;
      }
    }
    return null;
  };

  this.parse = function(me, source) {
    var R, lbracket, ref, stack, token, token_2, tokens, tos, type;
    tos = function() {
      var idx;
      if ((idx = stack.length - 1) < 0) {
        throw new Error("emtpy stack");
      }
      return stack[idx];
    };
    stack = [];
    R = [];
    tokens = this.tokenize(me, source);
    while (tokens.length > 0) {
      token = tokens.shift();
      switch (type = token.t) {
        case 'whitespace':
          continue;
        case 'number':
        case 'name':
          R.push(token);
          break;
        case 'lbracket':
          stack.push(token);
          break;
        case 'rbracket':

          /*
          If the token is a left parenthesis (i.e. "("), then push it onto the stack.
          If the token is a right parenthesis (i.e. ")"):
          Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.
          Pop the left parenthesis from the stack, but not onto the output queue.
          If the token at the top of the stack is a function token, pop it onto the output queue.
          If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.
           */
          lbracket = this._lbracket_from_rbracket(me, token);
          while (true) {
            if (!(stack.length > 0)) {
              throw new Error("### MEH ###");
            }
            token_2 = stack.pop();
            if (token_2.s !== lbracket) {
              R.push(token_2);
              continue;
            }
            break;
          }
          break;
        case 'operator':
          while (true) {
            if (!(stack.length > 0)) {
              break;
            }
            if ((token_2 = tos()).t !== 'operator') {
              break;
            }
            if (!(((token.a === 'left') && (token.p <= token_2.p)) || ((token.a === 'right') && (token.p < token_2.p)))) {
              break;
            }
            R.push(stack.pop());
          }
          stack.push(token);
          break;
        default:
          throw new Error("unsuppported or unknown token type " + (rpr(type)));
      }
    }
    while (true) {
      if (!(stack.length > 0)) {
        break;
      }
      token = stack.pop();
      if ((ref = token.t) === 'lbracket' || ref === 'rbracket') {
        throw new Error("illegal token on stack: " + (rpr(token)));
      }
      R.push(token);
    }
    return R;
  };

  this.demo = function() {

    /*
    
    **Usage**. First create a new grammar object, call it `g`.
    
    Define operators and their relative precedences implicity with `set_operator_precedence`; all operators
    in the earlier argument take precedence over those in the second.
    
    Operators that appear for the first time when they appear in one of the arguments to
    `set_operator_precedence` are automatically created and given an associativity (fixity) of `left`;
    therefore, at least those operators that need another associativity should be created explicitly
    before being mentioned in a precedence statement.
    
    After all operators have been entered and before any parsing is done, call `compile_operators` to
    turn the relative precedence rules into absolute precedence values.
    
    Add bracket pairs with `add_brackets`.
    
    Use `parse` to transform an infix expression to a list of tokens in postfix order.
     */
    var g;
    g = this.new_grammar();
    this.new_operator(g, '^', 'right');
    this.new_operator(g, '=', 'right');
    this.set_operator_precedence(g, ['*', '/'], ['+', '-']);
    this.set_operator_precedence(g, ['+', '-', '/', '*'], '=');
    this.set_operator_precedence(g, '^', ['+', '-', '/', '*']);
    debug(g);
    this.compile_operators(g);
    this.add_brackets(g, '(', ')');
    this.add_brackets(g, '[', ']');
    debug(g);
    info(this.tokenize(g, "( 4 + 4 ) * 3"));
    info('\n' + rpr(this.parse(g, "3 + 4")));
    info('\n' + rpr(this.parse(g, "a + 4")));
    info('\n' + rpr(this.parse(g, "3 + b")));
    info('\n' + rpr(this.parse(g, "a + b")));
    info('\n' + rpr(this.parse(g, "3 + 6 * 7")));
    info('\n' + rpr(this.parse(g, "3 * 6 + 7")));
    info('\n' + rpr(this.parse(g, "3 * ( 6 + 7 )")));
    info('\n' + rpr(this.parse(g, "() 3 * ( 6 + 7 )")));
    info('\n' + rpr(this.parse(g, "(3) * ( 6 + 7 )")));
    info('\n' + rpr(this.parse(g, "3*6^7")));
    info('\n' + rpr(this.parse(g, "6^7*3")));
    info('\n' + rpr(this.parse(g, "6+7+3")));
    info('\n' + rpr(this.parse(g, "6^7^3")));
    info('\n' + rpr(this.parse(g, "6 ^ 7 + 3")));
    info('\n' + rpr(this.parse(g, "6 ^ [ 7 + 3 ]")));
    info('\n' + rpr(this.parse(g, "a = 1")));
    info('\n' + rpr(this.parse(g, "a = b = c + 1")));
    return info('\n' + rpr(this.parse(g, "g = ( a + b ) * c ^ ( d - e )")));
  };

  if (module.parent == null) {
    this.demo();
  }

}).call(this);

//# sourceMappingURL=main.js.map
